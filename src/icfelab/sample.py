"""Module for sampling functions from gaussian processes. This includes an executable script for plotting single
sampled functions. This code has partially been generated by a LLM."""
import argparse
import json
import lzma
import time
from pathlib import Path
from typing import Any, Tuple

import numpy as np
from scipy.stats import beta
import matplotlib.pyplot as plt
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF
from tqdm import tqdm


def beta_sample_single_value(alpha: float = 1.0, beta_param: float = 10.0, scale: float = 1.0):
    """
    Samples a length_scale from a Beta distribution and rescales it.

    Parameters:
        alpha (float): Alpha parameter of the Beta distribution.
        beta_param (float): Beta parameter of the Beta distribution.
        scale (float): Maximum value for rescaling (default is 1.0 for [0, 1] range).

    Returns:
        float: A sampled length_scale value.
    """
    sampled_value = beta.rvs(alpha, beta_param)
    return sampled_value * scale


def sample_gp_rbf(x: np.ndarray, gaussian_process: GaussianProcessRegressor) -> np.ndarray:
    """Samples a function from a Gaussian Process with RBF kernel.
    Parameters:
        x(ndarray): The input values for which to sample the function.
        gaussian_process(GaussianProcessRegressor): The Gaussian Process instance.
    Returns:
        ndarray: sampled function values.
        """
    return gaussian_process.sample_y(x, n_samples=1).ravel()


def generate_functions(number_functions: int, number_samples: int):
    """Generate a number of functions and draw random samples of at least length 10 from all function points.
    Add gaussian noise to the sampled data with a random sampled std for each function.
    Args:
        number_functions: number of functions to generate.
        number_samples: number of random samples to draw for each function.
    """
    start = time.time()
    result_list = []
    for _ in tqdm(range(number_functions), desc="Generating functions", unit="functions"):
        gaussian_process, x_data, rbf_scale = create_gaussian_process()
        function = gaussian_process.sample_y(x_data, n_samples=1).ravel()

        std = abs(np.random.normal(0, 0.1, 1).item())

        data = []
        for _ in range(number_samples):
            data.append(add_gaussian_noise(sample_random_observation_grids(function), 0, std).tolist())
        result_list.append((function.tolist(), data, rbf_scale))
    save_compressed_json(result_list)
    end = time.time()
    print(f"gen+save took {end - start} seconds.")


def sample_random_observation_grids(function: np.ndarray):
    """Generate random grids to select a random number of points from this function."""
    function_size = len(function)
    random_grid = np.random.randint(low=0, high=1, size=function_size)
    number_of_samples = np.sum(random_grid).item()
    if number_of_samples < 10:
        additional_samples = np.random.randint(low=0, high=function_size, size=(10 - number_of_samples))
        random_grid[additional_samples] = 1
    return function[random_grid]


def add_gaussian_noise(data: np.ndarray, mean: float, std: float) -> np.ndarray:
    """
    Add gaussian noise to data.
    """
    noise = np.random.normal(loc=mean, scale=std, size=data.shape)
    return data + noise


def save_compressed_json(serializable_object: Any) -> None:
    """Compress and save json object."""
    json_str = json.dumps(serializable_object)
    json_bytes = json_str.encode('utf-8')

    Path(args.target_file).parent.mkdir(parents=True, exist_ok=True)
    with lzma.open(args.target_file, 'wb') as file:
        file.write(json_bytes)


def create_gaussian_process(grid_length: int = 128, interval: tuple = (0, 1)) -> Tuple[
    GaussianProcessRegressor, np.ndarray, float]:
    """Create a Gaussian process with RBF kernel."""
    x = np.linspace(0, 1, grid_length).reshape(-1, 1)
    rbf_scale = beta_sample_single_value()
    kernel = RBF(length_scale=rbf_scale)
    gaussian_process = GaussianProcessRegressor(kernel=kernel, alpha=1e-10)
    return gaussian_process, x, rbf_scale


def plot_single_function(x_data: np.ndarray, y_data: np.ndarray):
    plt.figure(figsize=(8, 4))
    plt.plot(x_data, y_data, label="GP sample", color='blue')
    plt.title("Sample from a Gaussian Process with RBF kernel")
    plt.xlabel("x")
    plt.ylabel("f(x)")
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    plt.show()


def get_args() -> argparse.Namespace:
    """
    Defines arguments.

    Returns:
        Namespace with parsed arguments.
    """
    parser = argparse.ArgumentParser(description="Sample random target interpolation functions.")
    parser.add_argument(
        "--target_file",
        "-f",
        type=str,
        default="functions.xz",
        help="File to save sampled functions to."
    )
    parser.add_argument(
        "--number-functions",
        "-n",
        type=int,
        default=100,
        help="Number of functions to generate."
    )
    parser.add_argument(
        "--number-samples",
        type=int,
        default=5,
        help="Number of samples to draw for each function."
    )
    return parser.parse_args()


if __name__ == "__main__":
    # gauss, x_data = create_gaussian_process()
    # y_data = gauss.sample_y(x_data, n_samples=1).ravel()
    # plot_single_function(x_data, y_data)
    args = get_args()
    generate_functions(args.number_functions, args.number_samples)
