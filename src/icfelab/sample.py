"""Module for sampling functions from gaussian processes. This includes an executable script for plotting single
sampled functions. This code has partially been generated by a LLM."""
import argparse
import json
import lzma
from pathlib import Path
from typing import Any, Tuple, Dict

import numpy as np
from numpy import ndarray
from scipy.stats import beta
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF
from tqdm import tqdm


def beta_sample_single_value(alpha: float = 1.0, beta_param: float = 10.0, scale: float = 1.0) -> float:
    """
    Samples a length_scale from a Beta distribution and rescales it.

    Parameters:
        alpha (float): Alpha parameter of the Beta distribution.
        beta_param (float): Beta parameter of the Beta distribution.
        scale (float): Maximum value for rescaling (default is 1.0 for [0, 1] range).

    Returns:
        float: A sampled length_scale value.
    """
    sampled_value = beta.rvs(alpha, beta_param)
    return sampled_value * scale


def sample_gp_rbf(x: np.ndarray, gaussian_process: GaussianProcessRegressor) -> ndarray:
    """Samples a function from a Gaussian Process with RBF kernel.
    Parameters:
        x(ndarray): The input values for which to sample the function.
        gaussian_process(GaussianProcessRegressor): The Gaussian Process instance.
    Returns:
        ndarray: sampled function values.
        """
    return gaussian_process.sample_y(x, n_samples=1).ravel()


def generate_functions(number_functions: int, target_path: Path) -> None:
    """Generate a number of functions and draw random samples of at least length 10 from all function points.
    Add gaussian noise to the sampled data with a random sampled std for each function.
    Args:
        number_functions: number of functions to generate.
        target_path: Path to the target file.
    """
    # start = time.time()
    result_list = []
    for _ in tqdm(range(number_functions), desc="Generating functions", unit="functions"):
        co_var, _, rbf_scale = create_covariance()
        function = np.random.multivariate_normal(mean=np.zeros(co_var.shape[0]), cov=co_var, size=1).squeeze()

        std = abs(np.random.normal(0, 0.1, 1).item())
        data = sample_random_observation_grids(function)
        data["values"] = add_gaussian_noise(data["values"], 0, std)  # type: ignore
        result_list.append({"target": function.tolist(), "input": data, "rbf_scale": rbf_scale})
    # for i, result in enumerate(result_list):
    #     plot_test(torch.tensor(result["target"]), torch.tensor(result["input"]["indices"]),
    #     torch.tensor(result["input"]["values"]), Path(f"data/generate/{i}.png"))
    # plot_target(torch.tensor(result["target"]), Path(f"data/generate/{i}.png"))
    save_compressed_json(result_list, target_path)
    # end = time.time()
    # print(f"gen+save took {end - start} seconds.")


def sample_random_observation_grids(function: np.ndarray) -> Dict[str, list]:
    """Generate random grids to select a random number of points from this function."""
    function_size = len(function)
    indices = np.arange(function_size)
    random_grid = np.random.randint(low=0, high=2, size=function_size).astype(bool)
    number_of_samples = np.sum(random_grid).item()
    if number_of_samples < 10:
        additional_samples = np.random.randint(low=0, high=function_size, size=10 - number_of_samples)
        random_grid[additional_samples] = True
    return {"values": function[random_grid].tolist(), "indices": indices[random_grid].tolist()}


def add_gaussian_noise(data: list, mean: float, std: float) -> ndarray:
    """
    Add gaussian noise to data.
    """
    data_ndarray = np.array(data)
    noise = np.random.normal(loc=mean, scale=std, size=data_ndarray.shape)
    return (data_ndarray + noise).tolist()


def save_compressed_json(serializable_object: Any, target_path: Path) -> None:
    """Compress and save json object."""
    json_str = json.dumps(serializable_object)
    json_bytes = json_str.encode('utf-8')

    target_path.parent.mkdir(parents=True, exist_ok=True)
    with lzma.open(target_path, 'wb') as file:
        file.write(json_bytes)


def create_covariance(grid_length: int = 128, interval: tuple = (0, 1)) -> Tuple[
    ndarray, ndarray, float]:
    """Create a Gaussian process with RBF kernel."""
    x = np.linspace(interval[0], interval[1], grid_length).reshape(-1, 1)
    rbf_scale = beta_sample_single_value()
    kernel = RBF(length_scale=rbf_scale)
    return kernel(x), x, rbf_scale


def get_args() -> argparse.Namespace:
    """
    Defines arguments.

    Returns:
        Namespace with parsed arguments.
    """
    parser = argparse.ArgumentParser(description="Sample random target interpolation functions.")
    parser.add_argument(
        "--target_file",
        "-f",
        type=str,
        default="functions.xz",
        help="File to save sampled functions to."
    )
    parser.add_argument(
        "--number-functions",
        "-n",
        type=int,
        default=100,
        help="Number of functions to generate."
    )
    return parser.parse_args()


if __name__ == "__main__":
    # gauss, x_data = create_gaussian_process()
    # y_data = gauss.sample_y(x_data, n_samples=1).ravel()
    # plot_single_function(x_data, y_data)
    args = get_args()
    generate_functions(args.number_functions, Path(args.target_file))
